# 🔧 行事曆事件重複問題修復說明

## 📋 問題描述

**問題**：編輯排班時，Google 行事曆會出現重複的事件

**原因**：
1. 原本的更新邏輯是「先刪除舊事件，再建立新事件」
2. 如果刪除失敗但建立成功 → 產生兩個事件
3. 如果 eventId 遺失或不正確 → 無法刪除舊事件，建立新事件後造成重複
4. 多次點擊儲存按鈕 → 每次都建立新事件

---

## ✅ 修復方案

### 1. 改用 Google Calendar API 的 `update` 方法

**修改前（有問題）：**
```javascript
async function autoUpdateCalendarEvent(eventId, shiftData) {
    // 先刪除舊事件
    await autoDeleteCalendarEvent(eventId);
    
    // 建立新事件
    const newEventId = await autoSyncShiftToCalendar(shiftData);
    return newEventId;
}
```

**修改後（解決方案）：**
```javascript
async function autoUpdateCalendarEvent(eventId, shiftData) {
    // 使用 update API 直接更新事件（不刪除再建立）
    const response = await gapi.client.calendar.events.update({
        calendarId: 'primary',
        eventId: eventId,
        resource: event,
        sendNotifications: true,
        sendUpdates: 'all'
    });
    
    return response.result.id; // 返回相同的事件ID
}
```

**優點：**
- ✅ 直接更新現有事件，不會產生重複
- ✅ 保持相同的 eventId
- ✅ 如果事件不存在（404 錯誤），才建立新事件

---

### 2. 防止重複點擊儲存按鈕

**新增功能：**
```javascript
async function saveShift() {
    // 禁用儲存按鈕
    const saveButtons = document.querySelectorAll('button[onclick="saveShift()"]');
    saveButtons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';
    });
    
    try {
        // ... 儲存邏輯 ...
    } catch (error) {
        // ... 錯誤處理 ...
    } finally {
        // 啟用按鈕
        saveButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        });
    }
}
```

**效果：**
- ✅ 點擊儲存後，按鈕立即禁用並變灰
- ✅ 防止用戶多次點擊
- ✅ 儲存完成後自動恢復按鈕狀態

---

## 🔍 修復詳情

### 修改的函數

#### 1. `autoUpdateCalendarEvent(eventId, shiftData)`
**位置**：約 3390 行

**主要改動：**
- 改用 `gapi.client.calendar.events.update` 而不是刪除再建立
- 保留相同的 eventId
- 加入 404 錯誤處理（事件不存在時建立新事件）
- 加入參與者郵件列表更新

#### 2. `saveShift()`
**位置**：約 2303 行

**主要改動：**
- 在函數開始時禁用儲存按鈕
- 使用 try-catch-finally 確保按鈕恢復
- 在所有可能的退出點都恢復按鈕狀態

---

## 📊 修復前後對比

### 修復前的流程：
```
編輯排班
  ↓
刪除舊事件 (可能失敗)
  ↓
建立新事件 (成功)
  ↓
結果：舊事件還在 + 新事件 = 重複！
```

### 修復後的流程：
```
編輯排班
  ↓
直接更新現有事件 (使用 update API)
  ↓
如果事件不存在（404）
  ↓
才建立新事件
  ↓
結果：只有一個事件，不重複！
```

---

## 🎯 測試方法

### 測試 1：更新現有排班

1. **建立一個排班**（啟用自動同步）
   - 確認 Google 行事曆出現事件

2. **編輯該排班**
   - 修改時間或人員
   - 點擊儲存

3. **檢查 Google 行事曆**
   - ✅ 應該只有一個事件（已更新）
   - ❌ 不應該有重複的事件

4. **檢查 Console 日誌**
   ```javascript
   🔄 自動更新行事曆事件：abc123xyz
   ✅ 行事曆事件已更新，事件ID：abc123xyz
   ```
   - 注意：更新前後的 eventId **相同**

### 測試 2：防止重複點擊

1. **建立或編輯排班**
2. **快速連續點擊儲存按鈕 2-3 次**
3. **檢查結果**
   - ✅ 按鈕應該在第一次點擊後立即禁用
   - ✅ 只執行一次儲存操作
   - ✅ 完成後按鈕自動恢復

### 測試 3：錯誤處理

1. **編輯排班但刪除原行事曆事件**
   - 手動在 Google 行事曆中刪除該事件
   
2. **回到排班系統編輯並儲存**

3. **檢查結果**
   - ✅ 系統偵測到 404 錯誤
   - ✅ 自動建立新事件
   - ✅ 不會卡住或報錯

---

## 🆘 如果已有重複事件

### 方法 1：手動清理

1. 開啟 Google 行事曆
2. 找到重複的排班事件
3. 手動刪除多餘的事件（保留其中一個）

### 方法 2：識別重複事件

重複事件的特徵：
- 相同的標題（事業單位名稱）
- 相同的日期和時間
- 不同的 eventId

### 方法 3：預防未來重複

- ✅ 確保已更新到最新版本
- ✅ 啟用自動同步功能
- ✅ 編輯排班時不要多次點擊儲存
- ✅ 讓系統自動管理行事曆事件

---

## 📝 Console 日誌說明

### 正確的更新流程日誌：

```javascript
// 編輯排班時
📝 開始編輯排班：{...}
✅ 編輯表單載入完成

// 儲存時
🔄 更新行事曆事件...
🔄 自動更新行事曆事件：abc123xyz
📧 更新參與者列表：[...]
✅ 行事曆事件已更新，事件ID：abc123xyz  // ← ID 相同！
📧 已發送更新通知給 X 位人員
```

### 錯誤的流程（已修復）：

```javascript
// 舊版本（會重複）
🗑️ 自動刪除行事曆事件：abc123xyz
✅ 行事曆事件已刪除
🔄 開始自動同步到行事曆...
✅ 自動同步成功，事件ID：xyz789def  // ← ID 不同！
```

---

## 🔄 更新日誌

### 版本 4.2.0 - 2026-01-17

**修復：**
- 🔧 修復編輯排班時行事曆事件重複的問題
- 🔧 改用 Calendar API 的 update 方法直接更新事件
- 🔧 加入防止重複點擊儲存按鈕的機制
- 🔧 加入 404 錯誤處理（事件不存在時自動建立）

**改進：**
- ✨ 更新時保持相同的 eventId
- ✨ 更新時自動發送郵件通知給參與者
- ✨ 按鈕禁用提供視覺回饋（變灰）
- ✨ 完整的錯誤處理機制

---

## 💡 最佳實踐

### 使用建議

1. **啟用自動同步**
   - 在「⚙️ 設定」頁籤勾選「啟用自動同步到 Google 行事曆」
   - 讓系統自動管理行事曆事件

2. **編輯排班時**
   - 點擊儲存後等待完成提示
   - 不要多次點擊儲存按鈕
   - 檢查 Console 確認更新成功

3. **清理舊資料**
   - 如果之前有重複事件，建議手動清理
   - 更新後新建立或編輯的排班不會再重複

4. **監控日誌**
   - 按 F12 開啟開發者工具
   - 查看 Console 日誌確認正常運作
   - 注意 eventId 是否保持一致

---

## 📞 技術支援

如遇到問題，請提供：

1. **Console 日誌**（F12 > Console）
2. **具體操作步驟**
3. **預期結果 vs 實際結果**
4. **是否仍出現重複事件**

---

## ✅ 修復確認清單

- [x] 修改 `autoUpdateCalendarEvent` 使用 update API
- [x] 加入 404 錯誤處理
- [x] 加入參與者郵件列表更新
- [x] 在 `saveShift` 函數加入按鈕禁用機制
- [x] 處理所有可能的退出點
- [x] 加入 try-catch-finally 錯誤處理
- [x] 測試無 linter 錯誤
- [x] 建立修復說明文件

修復完成！🎉
